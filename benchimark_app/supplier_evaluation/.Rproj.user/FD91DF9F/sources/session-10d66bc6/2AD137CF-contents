library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(shinyBS)
library(DT)
library(ggplot2)
library(GGally) # For ggparcoord
library(tidyr)
library(dplyr)
library(readr)
library(ggrepel) # For geom_text_repel
library(viridis) # For viridis color scales

# UI
ui <- dashboardPage(
  skin = "green",
  dashboardHeader(title = "Event Evaluation Tool"),
  dashboardSidebar(
    sidebarMenu(
      menuItem("Data Entry", tabName = "data", icon = icon("table")),
      menuItem("Analysis", tabName = "analysis", icon = icon("file-contract")),
      menuItem("Comparison", tabName = "comparison", icon = icon("chart-simple")),
      menuItem("Settings", tabName = "settings", icon = icon("cog"))
    )
  ),
  dashboardBody(
    # Custom CSS for colors
    tags$head(
      tags$style(HTML("
        /* Sidebar background color */
        .skin-green .left-side, .skin-green .main-sidebar, .skin-green .wrapper {
          background-color: #002900 !important;
        }

        /* Header (top bar) background color */
        .skin-green .main-header .navbar {
          background-color: #61A60E !important;
        }
        .skin-green .main-header .logo {
          background-color: #61A60E !important;
        }

        /* Tab color */
        .nav-tabs-custom > .nav-tabs > li.active {
          border-top-color: #61A60E !important;
        }

      /* Slider styling */
        /* Left part of the slider (selected range) */
        .irs-bar, .irs-bar-edge {
         background-color: #7C563A !important;
          border-color: #7C563A !important;
        }

        /* Slider handle (the point you drag) */
        .irs-handle {
         border: 1px solid #7C563A !important;
         background-color: #ffffff !important;
          }

        /* Slider handle when active/being moved */
        .irs-handle.state_hover, .irs-handle:hover {
          background-color: #f0f0f0 !important;
          }

        /* Right part of the slider (unselected range) */
        .irs-line {
          background-color: #e0e0e0 !important; /* Light grey */
          border-color: #d0d0d0 !important;
          }

          /* Slider track */
              .irs-line-mid, .irs-line-left, .irs-line-right {
             background-color: #e0e0e0 !important; /* Light grey */
            }

        /* Active tab background */
        .nav-tabs-custom > .nav-tabs > li.active > a {
          background-color: #edebeb;
          color: #444;
        }

        /* Info boxes header color */
        .box.box-primary > .box-header {
          background-color: #002900;
          color: #fff;
        }

        /* Change the border color of boxes */
        .box {
          border-top-color: #002900 !important;
          border-left: 1px solid #d2d6de;
          border-right: 1px solid #d2d6de;
          border-bottom: 1px solid #d2d6de;
        }

        /* Action buttons */
        .btn-primary {
          background-color: #002900;
          border-color: #002200;
        }

        .btn-primary:hover, .btn-primary:active, .btn-primary:focus {
          background-color: #003d00;
          border-color: #002200;
        }

        /* Active sidebar item */
        .skin-green .sidebar-menu > li.active > a,
        .skin-green .sidebar-menu > li:hover > a {
          background: #9a9a9a;
          border-left-color: #002900;
        }
      "))
    ),
    tabItems(
      # Data Entry Tab
      tabItem(
        tabName = "data",
        fluidRow(
          box(
            title = "Event Details", width = 12, status = "primary",
            fluidRow(
              column(3, textInput("expo_name", "Event Name", "")),
              column(3, numericInput("year", "Year", value = as.numeric(format(Sys.Date(), "%Y")))),
              # Input: Select countries
              column(3, selectInput(
                "location", "Select a City:",
                choices = NULL, # Choices will be populated from the CSV file
                multiple = FALSE
              )),
              column(
                3,
                div(
                  style = "display: flex; align-items: center;",
                  numericInput(inputId = "times", label = "Exhibiting Frequency", value = 1),
                  tipify(icon("info-circle"),
                    title = "Number of times participated as an exhibitor",
                    placement = "top"
                  )
                )
              )
            ),
            fluidRow(
              column(3, numericInput("booth_visitors", "Booth Visitors", value = 0)),
              column(3, numericInput("meetings", "Number of Meetings", value = 0)),
              column(3, numericInput("new_connections", "New Connections", value = 0)),
              column(3, numericInput("decision_makers", "Decision Makers", value = 0))
            ),
            tabBox(
              width = 12,
              tabPanel(
                title = "About Event",
                textAreaInput("about",
                  label = NULL,
                  placeholder = "Enter the information about the event by up to 40 words",
                  height = "100px", width = "100%"
                )
              ),
              tabPanel(
                title = "Strategic Reasons to Participate",
                textAreaInput("purpose",
                  label = NULL,
                  placeholder = "Enter the purpose of participating the event by up to 50 words",
                  height = "100px", width = "100%"
                )
              ),
              tabPanel(
                title = "Conclusion",
                textAreaInput("conclusion",
                  label = NULL,
                  placeholder = "Enter the conclusion up to 60 words",
                  height = "100px", width = "100%"
                )
              ),
              tabPanel(
                title = "Additional Notes",
                textAreaInput("notes",
                  label = NULL,
                  placeholder = "Enter the remarkable notes...",
                  height = "100px", width = "100%"
                )
              )
            ),
            fluidRow(
              column(
                4,
                tags$div(
                  tags$style(HTML("
      .custom-slider-labels {position: relative; height: 20px;}
      .custom-slider-labels .label-left {position: absolute; left: 0; bottom: -20px;}
      .custom-slider-labels .label-middle {position: absolute; left: 50%; transform: translateX(-50%); bottom: -20px;}
      .custom-slider-labels .label-right {position: absolute; right: 0; bottom: -20px;}

            /* Hide the default numeric labels */
      .custom-slider-labels .irs-min,
      .custom-slider-labels .irs-max,
      .custom-slider-labels .irs-single {
        display: none !important;
      }
    ")),
                  tags$div(
                    class = "custom-slider-labels",
                    sliderInput("relevance",
                      "Industry Relevance",
                      min = 1,
                      max = 10,
                      value = 5,
                      ticks = FALSE, # Hide the default ticks
                      step = 1
                    ),
                    tags$div(class = "label-left", "SEED"),
                    tags$div(class = "label-middle", "GROW"),
                    tags$div(class = "label-right", "FLORA"),
                    div(
                      style = "position: absolute; top: 0; right: 0px;",
                      tipify(icon("info-circle"),
                        title = "Rate the relevance of this EXPO to your industry sector",
                        placement = "right"
                      )
                    )
                  )
                )
              ),
              column(4, textInput("product", "Product Category")),
              column(4, numericInput("competitors", "Competitors Present", value = 0))
            ),
            actionButton("add_expo", "Add Event", icon = icon("plus")),
            actionButton("clear_form", "Clear Form", icon = icon("eraser"))
          )
        ),
        fluidRow(
          box(
            title = "Event Database", width = 12, status = "info",
            DTOutput("expo_table"),
            fluidRow(
              column(3, actionButton("delete_selected", "Delete Selected", icon = icon("trash"))),
              column(3, actionButton("edit_selected", "Edit Selected", icon = icon("edit"))),
              column(3, downloadButton("download_csv", "Download CSV")),
              column(3, actionButton("save_data", "Save Current Data", icon = icon("save")))
            )
          )
        )
      ),

      # Comparison Tab
      tabItem(
        tabName = "comparison",
        fluidRow(
          box(
            title = "Event Comparison Settings", width = 12, status = "primary",
            fluidRow(
              column(4, selectizeInput("select_expos", "Select Events to Compare",
                choices = NULL, multiple = TRUE
              )),
              column(4, selectInput("comparison_metric", "Primary Comparison Metric",
                choices = c(
                  "Net-Working" = "networking",
                  "Number of Seminars" = "seminars",
                  "Cost (EUR)" = "cost",
                  "Number of Exhibitors" = "exhibitors",
                  "Booth Visitors" = "booth_visitors",
                  "Number of Meetings" = "meetings",
                  "New Connections" = "new_connections",
                  "Industry Relevance" = "relevance",
                  "Decision Makers" = "decision_makers",
                  "Competitors Present" = "competitors"
                )
              )),
              column(4, selectInput("chart_type", "Chart Type",
                choices = c("Bar Chart", "Radar Chart", "Scatter Plot")
              ))
            ),
            actionButton("generate_comparison", "Generate Comparison", icon = icon("chart-line"))
          )
        ),
        fluidRow(
          box(
            title = "Comparison Results", width = 12, status = "info",
            plotOutput("comparison_plot", height = "500px"),
            DTOutput("comparison_table")
          )
        )
      ),


      # Analysis Tab
      tabItem(
        tabName = "analysis",
        fluidRow(
          box(
            title = "Event Analysis & Report", width = 12, status = "primary",
            fluidRow(
              column(4, selectInput("expo_analysis", "Select Event for Analysis:", choices = NULL))
            ),
            downloadButton("generatePDF", "Generate PDF",
              style = paste0("background-color: ", "#002900", "; color: white;")
            )
          )
        ),
        fluidRow(
          infoBoxOutput("dm_percentage_box", width = 4),
          infoBoxOutput("connection_conversion_box", width = 4),
          infoBoxOutput("meeting_conversion_box", width = 4)
        ),
        fluidRow(
          infoBoxOutput("cost_lead_box", width = 4),
          infoBoxOutput("cost_nc_box", width = 4),
          infoBoxOutput("cost_meeting_box", width = 4)
        ),
        fluidRow(
          tabBox(
            width = 12,
            tabPanel(
              title = "Visitor Funnel Analysis",
              status = "primary",
              solidHeader = TRUE,
              plotOutput("visitor_funnel", height = "300px")
            ),
            tabPanel(
              title = "ROI Quadrant Analysis",
              status = "primary",
              solidHeader = TRUE,
              plotOutput("roi_quadrant_plot", height = "300px")
            ),
            tabPanel(
              title = "Event Effectiveness Bar",
              status = "primary",
              solidHeader = TRUE,
              plotOutput("effectiveness_bar_plot", height = "300px")
            ),
            tabPanel(
              title = "Industry Relevance vs. Performance",
              status = "primary",
              solidHeader = TRUE,
              plotOutput("relevance_performance_plot", height = "300px")
            ),
            tabPanel(
              title = "Event Performance Over Time",
              status = "primary",
              solidHeader = TRUE,
              plotOutput("performance_over_time", height = "300px")
            )
          )
        )
      ),

      # Settings Tab
      tabItem(
        tabName = "settings",
        fluidRow(
          box(
            title = "Data Management", width = 6, status = "warning",
            fileInput("load_rds", "Load Saved Data (RDS file)", accept = ".rds"),
            actionButton("clear_all_data", "Clear All Data", icon = icon("exclamation-triangle")),
            hr(),
            textInput("data_file_name", "Data File Name for Saving", value = "expo_data"),
            actionButton("backup_data", "Create Backup", icon = icon("cloud-upload"))
          ),
          box(
            title = "Evaluation Weights", width = 6, status = "warning",
            p("Adjust the importance of each metric for overall Event value calculation"),
            sliderInput("weight_networking", "Net-Working Events", min = 0, max = 10, value = 5),
            sliderInput("weight_seminars", "Number of Seminars", min = 0, max = 10, value = 3),
            sliderInput("weight_cost", "Cost (EUR)", min = 0, max = 10, value = 7),
            sliderInput("weight_booth_visitors", "Booth Visitors", min = 0, max = 10, value = 6),
            sliderInput("weight_meetings", "Number of Meetings", min = 0, max = 10, value = 8),
            sliderInput("weight_new_connections", "New Connections", min = 0, max = 10, value = 7),
            sliderInput("weight_decision_makers", "Decision Makers", min = 0, max = 10, value = 9),
            actionButton("apply_weights", "Apply Weights", icon = icon("check"))
          )
        )
      )
    )
  )
)

# Server
server <- function(input, output, session) {
  # Load the csv file
  cities <- read_csv("data/cities.csv")

  # Initialize city choices when app starts
  observe({
    updateSelectInput(session, "location", choices = cities$city)
  })

  # Reactive expression to get the selected cities
  selected_city <- reactive({
    input$location
  })

  # Reactive values to store the EXPO data
  expo_data <- reactiveVal(data.frame(
    expo_name = character(),
    year = numeric(),
    location = character(),
    value_score = numeric(), # overall scores from all variables
    relevance = numeric(), # Industrial relevance score
    cost = numeric(), # If large number it gives negative
    times = numeric(),
    exhibitors = numeric(),
    networking = numeric(), # numbers of networking events
    seminars = numeric(), # numbers of seminar events
    decision_makers = numeric(), # Numbers of decision makers contacts
    new_connections = numeric(),
    meetings = numeric(),
    booth_visitors = numeric(),
    competitors = numeric(), # numbers of competitors
    about = character(),
    purpose = character(),
    conclusion = character(),
    notes = character(),
    product = character(),
    stringsAsFactors = FALSE
  ))

  # Keep track of the currently selected row for editing
  selected_row <- reactiveVal(NULL)
  editing_mode <- reactiveVal(FALSE)

  # Data file path for saving RDS
  data_file_path <- reactive({
    paste0(input$data_file_name, ".rds")
  })


  # Define calculation formula
  # value_score
  calculate_value_score <- function(expo) {
    # Make sure weights sum to 1
    weights <- c(
      networking = input$weight_networking / 100,
      seminars = input$weight_seminars / 100,
      cost = input$weight_cost / 100, # Keep as positive weight
      booth_visitors = input$weight_booth_visitors / 100,
      meetings = input$weight_meetings / 100,
      new_connections = input$weight_new_connections / 100,
      decision_makers = input$weight_decision_makers / 100
    )

    # Check if weights sum to 1
    if (abs(sum(weights) - 1) > 0.01) {
      warning("Weights don't sum to 1: ", sum(weights))
    }

    # Define a function to transform relevance scores into category names
    # relevance
    relevance_to_category <- function(relevance) {
      case_when(
        relevance >= 1 & relevance <= 3 ~ "SEED", # beginning stage, initial potential
        relevance >= 4 & relevance <= 6 ~ "GROW", # active development and expansion
        relevance >= 7 & relevance <= 9 ~ "ROOT", # stablishing fundamental strength and stability
        relevance == 10 ~ "FLORA", # fully realized, flourishing state
        TRUE ~ NA_character_ # Handle any other values
      )
    }

    # Create reactive relevance_category() that updates when input$relevance changes
    relevance_category <- reactive({
      relevance_category <- relevance_to_category(input$relevance)
    })

    # Normalize metrics to 0-1 scale using min-max normalization
    current_data <- expo_data()
    if (nrow(current_data) > 0) {
      normalized <- data.frame(
        networking = normalize_metric(expo$networking, current_data$networking, higher_is_better = TRUE),
        seminars = normalize_metric(expo$seminars, current_data$seminars, higher_is_better = TRUE),
        cost = normalize_metric(expo$cost, current_data$cost, higher_is_better = FALSE), # Lower cost is better
        booth_visitors = normalize_metric(expo$booth_visitors, current_data$booth_visitors, higher_is_better = TRUE),
        meetings = normalize_metric(expo$meetings, current_data$meetings, higher_is_better = TRUE),
        new_connections = normalize_metric(expo$new_connections, current_data$new_connections, higher_is_better = TRUE),
        decision_makers = normalize_metric(expo$decision_makers, current_data$decision_makers, higher_is_better = TRUE)
      )

      # Calculate weighted score
      score <- sum(
        normalized$networking * weights["networking"],
        normalized$seminars * weights["seminars"],
        normalized$cost * weights["cost"],
        normalized$booth_visitors * weights["booth_visitors"],
        normalized$meetings * weights["meetings"],
        normalized$new_connections * weights["new_connections"],
        normalized$decision_makers * weights["decision_makers"],
        na.rm = TRUE
      )

      # Scale to 0-100
      score <- round(score * 100)
    } else {
      score <- 50 # Default score for first entry
    }

    return(score)
  }

  # Helper function for consistent normalization
  normalize_metric <- function(value, all_values, higher_is_better = TRUE) {
    all_values <- c(all_values, value) # Include current value in normalization
    min_val <- min(all_values, na.rm = TRUE)
    max_val <- max(all_values, na.rm = TRUE)

    # Avoid division by zero
    if (max_val == min_val) {
      return(0.5) # Middle value if no variation
    }

    # Normalize
    normalized <- (value - min_val) / (max_val - min_val)

    # Invert if lower values are better
    if (!higher_is_better) {
      normalized <- 1 - normalized
    }

    return(normalized)
  }

  # Add or update EXPO
  observeEvent(input$add_expo, {
    if (input$expo_name == "") {
      showNotification("EXPO name is required", type = "error")
      return()
    }

    new_expo <- data.frame(
      expo_name = input$expo_name,
      year = input$year,
      location = input$location,
      times = input$times,
      networking = input$networking,
      seminars = input$seminars,
      cost = input$cost,
      exhibitors = input$exhibitors,
      booth_visitors = input$booth_visitors,
      meetings = input$meetings,
      new_connections = input$new_connections,
      about = input$about,
      purpose = input$purpose,
      conclusion = input$conclusion,
      notes = input$notes,
      product = input$product,
      competitors = input$competitors,
      relevance = input$relevance,
      decision_makers = input$decision_makers,
      value_score = 0, # Placeholder, will be calculated
      stringsAsFactors = FALSE
    )

    # Calculate value score
    new_expo$value_score <- calculate_value_score(new_expo)

    current_data <- expo_data()

    if (editing_mode()) {
      # Update existing record
      row_index <- selected_row()
      current_data[row_index, ] <- new_expo
      showNotification("EXPO updated successfully", type = "message")
      editing_mode(FALSE)
    } else {
      # Add new record
      current_data <- rbind(current_data, new_expo)
      showNotification("EXPO added successfully", type = "message")
    }

    expo_data(current_data)

    # Clear form
    updateTextInput(session, "expo_name", value = "")
    updateNumericInput(session, "year", value = as.numeric(format(Sys.Date(), "%Y")))
    # Don't reset location choices, just select the first one or empty
    if (length(cities$city) > 0) {
      updateSelectInput(session, "location", selected = "Milan")
    }
    updateNumericInput(session, "times", value = 1)
    updateNumericInput(session, "networking", value = 0)
    updateNumericInput(session, "seminars", value = 0)
    updateNumericInput(session, "cost", value = 0)
    updateNumericInput(session, "exhibitors", value = 0)
    updateNumericInput(session, "booth_visitors", value = 0)
    updateNumericInput(session, "meetings", value = 0)
    updateNumericInput(session, "new_connections", value = 0)
    updateTextAreaInput(session, "about", value = "")
    updateTextAreaInput(session, "purpose", value = "")
    updateTextAreaInput(session, "conclusion", value = "")
    updateTextAreaInput(session, "notes", value = "")
    updateTextInput(session, "product", value = "")
    updateNumericInput(session, "competitors", value = 0)
    updateSliderInput(session, "relevance", value = 5)
    updateNumericInput(session, "decision_makers", value = 0)

    # Save data after adding a new EXPO
    saveRDS(expo_data(), data_file_path())

    # Update choices for EXPO selection in comparison tab
    updateSelectizeInput(session, "select_expos",
      choices = expo_data()$expo_name
    )
  })

  # Clear form
  observeEvent(input$clear_form, {
    updateTextInput(session, "expo_name", value = "")
    updateNumericInput(session, "year", value = as.numeric(format(Sys.Date(), "%Y")))
    # Don't change the location choices, just reset the selection
    if (length(cities$city) > 0) {
      updateSelectInput(session, "location", selected = "Milan")
    }
    updateNumericInput(session, "times", value = 1)
    updateNumericInput(session, "networking", value = 0)
    updateNumericInput(session, "seminars", value = 0)
    updateNumericInput(session, "cost", value = 0)
    updateNumericInput(session, "exhibitors", value = 0)
    updateNumericInput(session, "booth_visitors", value = 0)
    updateNumericInput(session, "meetings", value = 0)
    updateNumericInput(session, "new_connections", value = 0)
    updateTextAreaInput(session, "about", value = "")
    updateTextAreaInput(session, "purpose", value = "")
    updateTextAreaInput(session, "conclusion", value = "")
    updateTextAreaInput(session, "notes", value = "")
    updateTextInput(session, "product", value = "")
    updateNumericInput(session, "competitors", value = 0)
    updateSliderInput(session, "relevance", value = 5)
    updateNumericInput(session, "decision_makers", value = 0)
    editing_mode(FALSE)
  })

  # Display EXPO table
  output$expo_table <- renderDT({
    datatable(
      expo_data() %>%
        select(!c(about, purpose, conclusion, notes)),
      selection = "single",
      options = list(
        pageLength = 10,
        lengthMenu = c(5, 10, 15, 20),
        order = list(list(7, "desc")), # Order by value score
        scrollX = TRUE, # Enable horizontal scrolling
        autoWidth = TRUE # Optimize column widths
      )
    )
  })

  # Handle delete selected
  observeEvent(input$delete_selected, {
    if (!is.null(input$expo_table_rows_selected)) {
      row_to_delete <- input$expo_table_rows_selected
      current_data <- expo_data()

      if (nrow(current_data) > 0 && row_to_delete <= nrow(current_data)) {
        current_data <- current_data[-row_to_delete, ]
        expo_data(current_data)

        # Save after deletion
        saveRDS(expo_data(), data_file_path())

        # Update choices for EXPO selection in comparison tab
        updateSelectizeInput(session, "select_expos",
          choices = expo_data()$expo_name
        )

        showNotification("EXPO deleted", type = "warning")
      }
    } else {
      showNotification("Please select an EXPO to delete", type = "error")
    }
  })

  # Handle edit selected
  observeEvent(input$edit_selected, {
    if (!is.null(input$expo_table_rows_selected)) {
      row_to_edit <- input$expo_table_rows_selected
      current_data <- expo_data()

      if (nrow(current_data) > 0 && row_to_edit <= nrow(current_data)) {
        selected_expo <- current_data[row_to_edit, ]

        # Populate form with selected EXPO data
        updateTextInput(session, "expo_name", value = selected_expo$expo_name)
        updateNumericInput(session, "year", value = selected_expo$year)
        updateSelectInput(session, "location", selected = selected_expo$location)
        updateNumericInput(session, "times", value = selected_expo$times)
        updateNumericInput(session, "exhibitors", value = selected_expo$exhibitors)
        updateNumericInput(session, "seminars", value = selected_expo$seminars)
        updateNumericInput(session, "networking", value = selected_expo$networking)
        updateNumericInput(session, "cost", value = selected_expo$cost)
        updateSliderInput(session, "relevance", value = selected_expo$relevance)
        updateNumericInput(session, "booth_visitors", value = selected_expo$booth_visitors)
        updateNumericInput(session, "new_connections", value = selected_expo$new_connections)
        updateNumericInput(session, "meetings", value = selected_expo$meetings)
        updateNumericInput(session, "decision_makers", value = selected_expo$decision_makers)
        updateTextAreaInput(session, "about", value = selected_expo$about)
        updateTextAreaInput(session, "purpose", value = selected_expo$purpose)
        updateTextAreaInput(session, "conclusion", value = selected_expo$conclusion)
        updateTextAreaInput(session, "notes", value = selected_expo$notes)
        updateTextInput(session, "product", value = selected_expo$product)
        updateNumericInput(session, "competitors", value = selected_expo$competitors)

        # Set editing mode and store selected row
        editing_mode(TRUE)
        selected_row(row_to_edit)

        showNotification("Editing expo. Click 'Add event' to save changes.", type = "message")
      }
    } else {
      showNotification("Please select an event to edit", type = "error")
    }
  })

  # Save current data
  observeEvent(input$save_data, {
    if (nrow(expo_data()) > 0) {
      saveRDS(expo_data(), data_file_path())
      showNotification(paste("Data saved to", data_file_path()), type = "message")
    } else {
      showNotification("No data to save", type = "warning")
    }
  })

  # Create backup
  observeEvent(input$backup_data, {
    if (nrow(expo_data()) > 0) {
      backup_file <- paste0(input$data_file_name, "_backup_", format(Sys.time(), "%Y%m%d_%H%M"), ".rds")
      saveRDS(expo_data(), backup_file)
      showNotification(paste("Backup created:", backup_file), type = "message")
    } else {
      showNotification("No data to backup", type = "warning")
    }
  })

  # Load data from RDS
  observeEvent(input$load_rds, {
    tryCatch(
      {
        loaded_data <- readRDS(input$load_rds$datapath)
        expo_data(loaded_data)

        # Update choices for EXPO selection in comparison tab
        updateSelectizeInput(session, "select_expos",
          choices = loaded_data$expo_name
        )

        showNotification("Data loaded successfully", type = "message")
      },
      error = function(e) {
        showNotification(paste("Error loading data:", e$message), type = "error")
      }
    )
  })

  # Clear all data
  observeEvent(input$clear_all_data, {
    showModal(modalDialog(
      title = "Confirm",
      "Are you sure you want to clear all event data? This cannot be undone.",
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_clear", "Yes, Clear All Data", class = "btn-danger")
      )
    ))
  })

  observeEvent(input$confirm_clear, {
    expo_data(data.frame(
      expo_name = character(),
      year = numeric(),
      location = character(),
      times = numeric(),
      networking = numeric(),
      seminars = numeric(), # numbers of seminars during an expo
      cost = numeric(),
      exhibitors = numeric(), # total numbers of exhibitors
      booth_visitors = numeric(),
      meetings = numeric(),
      new_connections = numeric(),
      about = character(),
      purpose = character(),
      conclusion = character(),
      notes = character(),
      product = character(),
      competitors = numeric(),
      relevance = numeric(),
      decision_makers = numeric(),
      value_score = numeric(),
      stringsAsFactors = FALSE
    ))

    # Update choices for expo selection in comparison tab
    updateSelectizeInput(session, "select_expos", choices = character(0))

    removeModal()
    showNotification("All data cleared", type = "warning")
  })

  # Download CSV
  output$download_csv <- downloadHandler(
    filename = function() {
      paste(input$data_file_name, ".csv", sep = "")
    },
    content = function(file) {
      write_csv(expo_data(), file)
    }
  )

  # Apply weights and recalculate value scores
  observeEvent(input$apply_weights, {
    current_data <- expo_data()

    if (nrow(current_data) > 0) {
      # Recalculate value scores for all expos
      for (i in 1:nrow(current_data)) {
        current_data$value_score[i] <- calculate_value_score(current_data[i, ])
      }

      expo_data(current_data)
      showNotification("Weights applied and scores recalculated", type = "message")
    }
  })

  observe({
    if (nrow(expo_data()) > 0) {
      # Create options with both name and year
      expo_options <- expo_data() %>%
        mutate(expo_display = paste0(expo_name, " (", year, ")")) %>%
        select(expo_display, expo_name, year)

      updateSelectizeInput(session, "select_expos",
        choices = setNames(expo_options$expo_display, expo_options$expo_display)
      )
    }
  })

  # Generate comparison visualization
  observeEvent(input$generate_comparison, {
    req(input$select_expos, input$comparison_metric)

    selected_expo_displays <- input$select_expos
    metric <- input$comparison_metric

    # Parse the selected Event displays to get name and year
    selected_expos <- lapply(selected_expo_displays, function(display) {
      # Extract expo_name and year from the format "expo_name (year)"
      matches <- regmatches(display, regexec("(.*) \\((\\d+)\\)$", display))[[1]]
      if (length(matches) >= 3) {
        return(list(name = matches[2], year = as.numeric(matches[3])))
      } else {
        return(NULL)
      }
    })

    # Filter expo data based on parsed selections
    comparison_data <- data.frame()
    for (expo in selected_expos) {
      if (!is.null(expo)) {
        filtered <- expo_data() %>%
          filter(expo_name == expo$name & year == expo$year)
        comparison_data <- rbind(comparison_data, filtered)
      }
    }

    # Add display name column for plotting
    comparison_data <- comparison_data %>%
      mutate(expo_display = paste0(expo_name, " (", year, ")"))

    if (nrow(comparison_data) < 2) {
      showNotification("Please select at least two EXPOs to compare", type = "warning")
      return()
    }

    # Generate comparison table
    output$comparison_table <- renderDT({
      datatable(
        comparison_data %>%
          select(
            expo_display, networking, seminars, cost, exhibitors,
            booth_visitors, meetings, new_connections, decision_makers, relevance, value_score
          ),
        options = list(
          pageLength = 10,
          dom = "t" # Show only table, no search or pagination
        ),
        colnames = c("Event" = 1)
      )
    })

    # Generate chart based on chart type
    output$comparison_plot <- renderPlot({
      if (input$chart_type == "Bar Chart") {
        # Bar chart - using expo_display instead of expo_name
        metric_label <- names(which(input$comparison_metric == colnames(comparison_data)))
        if (length(metric_label) == 0) metric_label <- gsub("_", " ", input$comparison_metric) %>% tools::toTitleCase()

        ggplot(comparison_data, aes(x = reorder(expo_display, get(metric)), y = get(metric))) +
          geom_bar(stat = "identity", fill = "#61A60E") +
          geom_text(aes(label = get(metric)), vjust = -0.5, colour = "#61A60E", size = 5, fontface = "bold") +
          labs(
            title = paste("Event Comparison by", metric_label),
            x = "Event",
            y = metric_label
          ) +
          theme_minimal() +
          theme(
            axis.text.x = element_text(size = 11, angle = 0, hjust = 0.5),
            panel.grid.minor = element_blank(),
            panel.grid.major.x = element_blank()
          )
      } else if (input$chart_type == "Radar Chart") {
        # Prepare data for radar chart
        radar_metrics <- c(
          "networking", "seminars", "booth_visitors", "meetings",
          "new_connections", "decision_makers", "value_score"
        )

        #  Define their order
        ordered_metrics <- c(
          "Networking", "Seminars", "Booth Visitors", "Meetings",
          "New Connections", "Decision Makers", "Value Score"
        )

        # Define the metric labels
        label_metrics <- c(
          "Networking", "Seminars", "Booth \nVisitors", "Meetings",
          "New Connections", "Decision \nMakers", "Value Score"
        )
        # Normalize data for radar chart
        radar_data <- comparison_data %>%
          select(expo_display, all_of(radar_metrics)) %>%
          mutate(across(all_of(radar_metrics), ~ . / max(., na.rm = TRUE) * 100))

        # Convert to long format for radar chart
        radar_long <- radar_data %>%
          pivot_longer(
            cols = -expo_display,
            names_to = "metric",
            values_to = "value"
          ) %>%
          # Improve metric labels
          mutate(metric = case_when(
            metric == "networking" ~ "Networking",
            metric == "seminars" ~ "Seminars",
            metric == "booth_visitors" ~ "Booth Visitors",
            metric == "meetings" ~ "Meetings",
            metric == "new_connections" ~ "New Connections",
            metric == "decision_makers" ~ "Decision Makers",
            metric == "value_score" ~ "Value Score",
            TRUE ~ metric
          ))

        # Ensure metrics are properly ordered
        radar_long$metric <- factor(radar_long$metric, levels = ordered_metrics)

        # Create a coordinate calculation function for the radar chart
        calculate_radar_coords <- function(data) {
          # Number of metrics (axes)
          n_metrics <- length(unique(data$metric))

          # Calculate angle for each metric position
          angles <- 2 * pi * (0:(n_metrics - 1)) / n_metrics

          # Calculate coordinates
          data %>%
            arrange(expo_display, metric) %>%
            group_by(expo_display) %>%
            mutate(
              # Get the index of each metric in the ordered list
              angle = match(as.character(metric), ordered_metrics) - 1,
              # Convert to radians
              angle = 2 * pi * angle / n_metrics,
              # Calculate x and y coordinates
              x = value * sin(angle),
              y = value * cos(angle)
            ) %>%
            # Make sure each group has a complete path by adding first point at the end
            group_modify(~ {
              rbind(.x, .x[1, ]) # Add first row to the end of each group
            }) %>%
            ungroup()
        }

        # Calculate coordinates for the radar chart
        radar_coords <- calculate_radar_coords(radar_long)

        # Create radar chart using calculated coordinates
        ggplot() +
          # Add grid lines
          geom_polygon(
            data = data.frame(
              x = 25 * sin(2 * pi * (0:100) / 100),
              y = 25 * cos(2 * pi * (0:100) / 100)
            ),
            aes(x, y), fill = NA, color = "gray90"
          ) +
          geom_polygon(
            data = data.frame(
              x = 50 * sin(2 * pi * (0:100) / 100),
              y = 50 * cos(2 * pi * (0:100) / 100)
            ),
            aes(x, y), fill = NA, color = "gray90"
          ) +
          geom_polygon(
            data = data.frame(
              x = 75 * sin(2 * pi * (0:100) / 100),
              y = 75 * cos(2 * pi * (0:100) / 100)
            ),
            aes(x, y), fill = NA, color = "gray90"
          ) +
          geom_polygon(
            data = data.frame(
              x = 100 * sin(2 * pi * (0:100) / 100),
              y = 100 * cos(2 * pi * (0:100) / 100)
            ),
            aes(x, y), fill = NA, color = "gray90"
          ) +

          # Add radial lines
          sapply(1:length(ordered_metrics), function(i) {
            angle <- 2 * pi * (i - 1) / length(ordered_metrics)
            geom_segment(
              aes(x = 0, y = 0, xend = 110 * sin(angle), yend = 110 * cos(angle)),
              color = "gray90"
            )
          }) +

          # Add actual data polygons
          geom_polygon(
            data = radar_coords,
            aes(x = x, y = y, group = expo_display, fill = expo_display),
            alpha = 0.2
          ) +

          # Add lines and points
          geom_path(
            data = radar_coords,
            aes(x = x, y = y, group = expo_display, color = expo_display),
            size = 1
          ) +
          geom_point(
            data = radar_coords %>% group_by(expo_display, metric) %>% slice(1),
            aes(x = x, y = y, color = expo_display),
            size = 3
          ) +

          # Add axis labels
          sapply(1:length(label_metrics), function(i) {
            angle <- 2 * pi * (i - 1) / length(label_metrics)
            geom_text(
              aes(
                x = 120 * sin(angle), y = 120 * cos(angle),
                label = label_metrics[i]
              ),
              hjust = ifelse(sin(angle) < 0, 0.5, 0),
              vjust = ifelse(cos(angle) < 0, 0, 0.5),
              size = 3.5
            )
          }) +

          # Add percentage labels
          geom_text(
            data = data.frame(
              x = 0,
              y = c(25, 50, 75, 100),
              label = c("25%", "50%", "75%", "100%")
            ),
            aes(x = x, y = y, label = label),
            size = 3,
            color = "gray50"
          ) +

          # Set equal coordinates with expanded limits
          coord_fixed(xlim = c(-150, 150), ylim = c(-150, 150)) +

          # Add titles and theme
          labs(
            title = "Event Comparison - Multiple Metrics",
            subtitle = "Normalized values (% of maximum)",
            color = "Event",
            fill = "Event"
          ) +
          theme_void() +
          theme(
            legend.position = "bottom",
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5),
            plot.margin = margin(t = 30, r = 40, b = 30, l = 40) # Add generous margins
          )
      } else if (input$chart_type == "Scatter Plot") {
        # Scatter plot (cost vs. selected metric)
        second_metric <- if (metric == "cost") "booth_visitors" else "cost"

        metric_label <- names(which(metric == colnames(comparison_data)))
        if (length(metric_label) == 0) metric_label <- gsub("_", " ", metric) %>% tools::toTitleCase()

        second_metric_label <- names(which(second_metric == colnames(comparison_data)))
        if (length(second_metric_label) == 0) second_metric_label <- gsub("_", " ", second_metric) %>% tools::toTitleCase()

        ggplot(comparison_data, aes(x = get(second_metric), y = get(metric), size = value_score)) +
          geom_point(aes(color = expo_display), alpha = 0.7) +
          geom_text_repel(aes(label = expo_display), size = 8) +
          labs(
            title = paste(metric_label, "vs.", second_metric_label),
            x = second_metric_label,
            y = metric_label,
            size = "Value Score",
            color = "Event"
          ) +
          theme_minimal() +
          theme(legend.position = "bottom")
      }
    })
  })


  # Initialize the app with example data or load existing data if available
  observe({
    # Initialize city choices when app starts
    updateSelectInput(session, "location", choices = cities$city, selected = "Milan")

    if (file.exists(data_file_path())) {
      # Load existing data if available
      tryCatch(
        {
          loaded_data <- readRDS(data_file_path())
          expo_data(loaded_data)

          # Update choices for expo selection in comparison tab
          updateSelectizeInput(session, "select_expos",
            choices = loaded_data$expo_name
          )
        },
        error = function(e) {
          # Just log error and start with empty dataset
          cat("Error loading existing data:", e$message, "\n")
        }
      )
    }
  })

  # ANALYSIS PART
  # Update the expo selection dropdown
  observe({
    if (nrow(expo_data()) > 0) {
      # Create a unique list of expo names
      unique_expos <- unique(expo_data()$expo_name)
      updateSelectInput(session, "expo_analysis", choices = unique_expos)
    }
  })

  # Get the most recent expo data for the selected expo
  selected_expo_data <- reactive({
    req(input$expo_analysis)

    # Filter for selected expo
    expo_subset <- expo_data() %>%
      filter(expo_name == input$expo_analysis)

    # Get the most recent year
    max_year <- max(expo_subset$year)

    # Filter for the most recent year's data
    expo_subset %>%
      filter(year == max_year) %>%
      # If there are multiple entries in the same year, get the one with the highest 'times' value
      filter(times == max(times))
  })

  # Get trend data for the selected expo (if shown multiple times)
  expo_trend_data <- reactive({
    req(input$expo_analysis)

    # Get all entries for this expo
    all_entries <- expo_data() %>%
      filter(expo_name == input$expo_analysis) %>%
      arrange(year, times)

    all_entries
  })

  # Decision Makers Percentage ValueBox
  output$dm_percentage_box <- renderValueBox({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Calculate percentage of decision makers from booth visitors
    dm_percentage <- ifelse(data$booth_visitors > 0,
      round(data$decision_makers / data$booth_visitors * 100, 1),
      0
    )

    # Get trend data if available
    trend_data <- expo_trend_data()
    trend_icon <- NULL
    trend_color <- "aqua"
    trend_text <- ""

    if (nrow(trend_data) > 1) {
      # Sort by year and times
      trend_data <- trend_data %>% arrange(year, times)

      # Get index of current data in trend_data
      current_idx <- which(trend_data$year == data$year & trend_data$times == data$times)

      # Check if there's a previous entry
      if (current_idx > 1) {
        prev_data <- trend_data[current_idx - 1, ]
        prev_dm_percentage <- ifelse(prev_data$booth_visitors > 0,
          round(prev_data$decision_makers / prev_data$booth_visitors * 100, 1),
          0
        )

        # Calculate trend
        dm_change <- dm_percentage - prev_dm_percentage

        if (dm_change > 0) {
          trend_icon <- "arrow-up"
          trend_color <- "green"
          trend_text <- paste0(" (+", dm_change, "%)")
        } else if (dm_change < 0) {
          trend_icon <- "arrow-down"
          trend_color <- "red"
          trend_text <- paste0(" (", dm_change, "%)")
        } else {
          trend_icon <- "arrows-h"
          trend_color <- "blue"
          trend_text <- " (no change)"
        }
      }
    }

    valueBox(
      value = paste0(dm_percentage, "%"),
      subtitle = HTML(paste0("Decision Makers Percentage\n", trend_text)),
      icon = icon(ifelse(is.null(trend_icon), "users", trend_icon)),
      color = trend_color
    )
  })

  # Meeting Conversion Rate ValueBox
  output$meeting_conversion_box <- renderValueBox({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Calculate meeting conversion rate
    meeting_conv <- ifelse(data$booth_visitors > 0,
      round(data$meetings / data$booth_visitors * 100, 1),
      0
    )

    # Get trend data if available
    trend_data <- expo_trend_data()
    trend_icon <- NULL
    trend_color <- "aqua"
    trend_text <- ""

    if (nrow(trend_data) > 1) {
      # Sort by year and times
      trend_data <- trend_data %>% arrange(year, times)

      # Get index of current data in trend_data
      current_idx <- which(trend_data$year == data$year & trend_data$times == data$times)

      # Check if there's a previous entry
      if (current_idx > 1) {
        prev_data <- trend_data[current_idx - 1, ]
        prev_meeting_conv <- ifelse(prev_data$booth_visitors > 0,
          round(prev_data$meetings / prev_data$booth_visitors * 100, 1),
          0
        )

        # Calculate trend
        meeting_change <- meeting_conv - prev_meeting_conv

        if (meeting_change > 0) {
          trend_icon <- "arrow-up"
          trend_color <- "green"
          trend_text <- paste0(" (+", meeting_change, "%)")
        } else if (meeting_change < 0) {
          trend_icon <- "arrow-down"
          trend_color <- "red"
          trend_text <- paste0(" (", meeting_change, "%)")
        } else {
          trend_icon <- "arrows-h"
          trend_color <- "blue"
          trend_text <- " (no change)"
        }
      }
    }

    valueBox(
      value = paste0(meeting_conv, "%"),
      subtitle = HTML(paste0("Meeting Conversion Rate<br>", trend_text)),
      icon = icon(ifelse(is.null(trend_icon), "handshake", trend_icon)),
      color = trend_color
    )
  })

  # New Connections Rate ValueBox
  output$connection_conversion_box <- renderValueBox({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Calculate new connections conversion rate
    connection_conv <- ifelse(data$booth_visitors > 0,
      round(data$new_connections / data$booth_visitors * 100, 1),
      0
    )

    # Get trend data if available
    trend_data <- expo_trend_data()
    trend_icon <- NULL
    trend_color <- "aqua"
    trend_text <- ""

    if (nrow(trend_data) > 1) {
      # Sort by year and times
      trend_data <- trend_data %>% arrange(year, times)

      # Get index of current data in trend_data
      current_idx <- which(trend_data$year == data$year & trend_data$times == data$times)

      # Check if there's a previous entry
      if (current_idx > 1) {
        prev_data <- trend_data[current_idx - 1, ]
        prev_connection_conv <- ifelse(prev_data$booth_visitors > 0,
          round(prev_data$new_connections / prev_data$booth_visitors * 100, 1),
          0
        )

        # Calculate trend
        connection_change <- connection_conv - prev_connection_conv

        if (connection_change > 0) {
          trend_icon <- "arrow-up"
          trend_color <- "green"
          trend_text <- paste0(" (+", connection_change, "%)")
        } else if (connection_change < 0) {
          trend_icon <- "arrow-down"
          trend_color <- "red"
          trend_text <- paste0(" (", connection_change, "%)")
        } else {
          trend_icon <- "arrows-h"
          trend_color <- "blue"
          trend_text <- " (no change)"
        }
      }
    }

    valueBox(
      value = paste0(connection_conv, "%"),
      subtitle = HTML(paste0("New Connections Rate<br>", trend_text)),
      icon = icon(ifelse(is.null(trend_icon), "link", trend_icon)),
      color = trend_color
    )
  })

  # Cost per Lead ValueBox
  output$cost_lead_box <- renderValueBox({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Calculate costs per lead(booth visitors)
    cost_lead <- ifelse(data$booth_visitors > 0,
      round(data$cost / data$booth_visitors, 2),
      0
    )

    # Get trend data if available
    trend_data <- expo_trend_data()
    trend_icon <- NULL
    trend_color <- "aqua"
    trend_text <- ""

    if (nrow(trend_data) > 1) {
      # Sort by year and times
      trend_data <- trend_data %>% arrange(year, times)

      # Get index of current data in trend_data
      current_idx <- which(trend_data$year == data$year & trend_data$times == data$times)

      # Check if there's a previous entry
      if (current_idx > 1) {
        prev_data <- trend_data[current_idx - 1, ]
        prev_cost_lead <- ifelse(prev_data$booth_visitors > 0,
          round(prev_data$cost / prev_data$booth_visitors, 2),
          0
        )

        # Calculate trend
        cost_lead_change <- cost_lead - prev_cost_lead

        if (cost_lead_change < 0) {
          trend_icon <- "arrow-down"
          trend_color <- "green"
          trend_text <- paste0(" (", cost_lead_change, "€)")
        } else if (cost_lead_change > 0) {
          trend_icon <- "arrow-up"
          trend_color <- "red"
          trend_text <- paste0(" (+", cost_lead_change, "€)")
        } else {
          trend_icon <- "arrows-h"
          trend_color <- "blue"
          trend_text <- " (no change)"
        }
      }
    }

    valueBox(
      value = paste0(cost_lead, "€"),
      subtitle = HTML(paste0("Cost per Lead<br>", trend_text)),
      icon = icon(ifelse(is.null(trend_icon), "euro-sign", trend_icon)),
      color = trend_color
    )
  })

  # Cost per Meeting ValueBox
  output$cost_meeting_box <- renderValueBox({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Calculate costs per meeting
    cost_meeting <- ifelse(data$meetings > 0,
      round(data$cost / data$meetings, 1),
      0
    )

    # Get trend data if available
    trend_data <- expo_trend_data()
    trend_icon <- NULL
    trend_color <- "aqua"
    trend_text <- ""

    if (nrow(trend_data) > 1) {
      # Sort by year and times
      trend_data <- trend_data %>% arrange(year, times)

      # Get index of current data in trend_data
      current_idx <- which(trend_data$year == data$year & trend_data$times == data$times)

      # Check if there's a previous entry
      if (current_idx > 1) {
        prev_data <- trend_data[current_idx - 1, ]
        prev_cost_meeting <- ifelse(prev_data$meetings > 0,
          round(prev_data$cost / prev_data$meetings, 1),
          0
        )

        # Calculate trend
        cost_meeting_change <- cost_meeting - prev_cost_meeting

        if (cost_meeting_change < 0) {
          trend_icon <- "arrow-down"
          trend_color <- "green"
          trend_text <- paste0(" (", cost_meeting_change, "€)")
        } else if (cost_meeting_change > 0) {
          trend_icon <- "arrow-up"
          trend_color <- "red"
          trend_text <- paste0(" (+", cost_meeting_change, "€)")
        } else {
          trend_icon <- "arrows-h"
          trend_color <- "blue"
          trend_text <- " (no change)"
        }
      }
    }

    valueBox(
      value = paste0(cost_meeting, "€"),
      subtitle = HTML(paste0("Cost per Meeting<br>", trend_text)),
      icon = icon(ifelse(is.null(trend_icon), "comments-dollar", trend_icon)),
      color = trend_color
    )
  })

  # Cost per New Connection ValueBox
  output$cost_nc_box <- renderValueBox({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Calculate costs per new connection
    cost_nc <- ifelse(data$new_connections > 0,
      round(data$cost / data$new_connections, 2),
      0
    )

    # Get trend data if available
    trend_data <- expo_trend_data()
    trend_icon <- NULL
    trend_color <- "aqua"
    trend_text <- ""

    if (nrow(trend_data) > 1) {
      # Sort by year and times
      trend_data <- trend_data %>% arrange(year, times)

      # Get index of current data in trend_data
      current_idx <- which(trend_data$year == data$year & trend_data$times == data$times)

      # Check if there's a previous entry
      if (current_idx > 1) {
        prev_data <- trend_data[current_idx - 1, ]
        prev_cost_nc <- ifelse(prev_data$new_connections > 0,
          round(prev_data$cost / prev_data$new_connections, 2),
          0
        )

        # Calculate trend
        cost_nc_change <- cost_nc - prev_cost_nc

        if (cost_nc_change < 0) {
          trend_icon <- "arrow-down"
          trend_color <- "green"
          trend_text <- paste0(" (", cost_nc_change, "€)")
        } else if (cost_nc_change > 0) {
          trend_icon <- "arrow-up"
          trend_color <- "red"
          trend_text <- paste0(" (+", cost_nc_change, "€)")
        } else {
          trend_icon <- "arrows-h"
          trend_color <- "blue"
          trend_text <- " (no change)"
        }
      }
    }

    valueBox(
      value = paste0(cost_nc, "€"),
      subtitle = HTML(paste0("Cost per New Connection\n", trend_text)),
      icon = icon(ifelse(is.null(trend_icon), "money-bill-wave", trend_icon)),
      color = trend_color
    )
  })

  # 1 Render visitor funnel chart
  output$visitor_funnel <- renderPlot({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Create funnel data - order stages logically from highest to lowest number
    funnel_data <- data.frame(
      stage = c("Booth Visitors", "New Connections", "Meetings", "Decision Makers"),
      value = c(data$booth_visitors, data$new_connections, data$meetings, data$decision_makers)
    )

    # Set the order of the stages for proper funnel visualization
    funnel_data$stage <- factor(funnel_data$stage,
      levels = c("Booth Visitors", "Meetings", "New Connections", "Decision Makers")
    )
    # Create the bar chart

    ggplot(funnel_data, aes(x = stage, y = value)) +
      geom_bar(stat = "identity", fill = "#61A60E", width = 0.7) +
      geom_text(aes(label = value), fontface = "bold", family = "Verdana", color = "#61A60E", vjust = -0.5) +
      labs(x = "", y = "") +
      theme_minimal() +
      theme(
        axis.text.x = element_text(hjust = 0.5, size = 12, color = "#B2B2B2"),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(color = "#B2B2B2", linewidth = 1),
        panel.border = element_blank(),
        plot.margin = margin(t = 0, r = 0, b = 0, l = 0)
      ) +
      scale_y_continuous(
        limits = c(0, max(funnel_data$value) * 1.2),
        breaks = c(0)
      ) + # Only include the 0 break for y-axis
      scale_x_discrete(labels = function(x) {
        lapply(x, function(y) gsub(" ", "\n", y))
      })
  })


  # 2. ROI Quadrant Analysis
  output$roi_quadrant_plot <- renderPlot({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Get all expos for comparison
    all_expos <- expo_data()

    # Create the meeting_cost variable correctly
    all_expos <- df_all %>%
      mutate(
        meeting_cost = round(cost / meetings, 2),
        roi_label = paste0(expo_name, "-", year, "\nCost: €", meeting_cost, "\nScore:", value_score)
      )

    # Add flag for selected expo and year
    all_expos <- all_expos %>%
      mutate(is_selected = (expo_name == data$expo_name[1] & year == data$year[1]))

    # Calculate medians based on the new meeting_cost variable
    median_meeting_cost <- median(all_expos$meeting_cost)
    median_value <- median(all_expos$value_score)

    # Recalculate quadrants using meeting_cost instead of cost
    all_expos <- all_expos %>%
      mutate(quadrant = case_when(
        meeting_cost <= median_meeting_cost & value_score >= median_value ~ "High Value / Low Cost",
        meeting_cost > median_meeting_cost & value_score >= median_value ~ "High Value / High Cost",
        meeting_cost <= median_meeting_cost & value_score < median_value ~ "Low Value / Low Cost",
        meeting_cost > median_meeting_cost & value_score < median_value ~ "Low Value / High Cost"
      ))

    # Create the executive style plot
    exec_quadrat <- ggplot(all_expos, aes(x = meeting_cost, y = value_score)) +
      # Add reference lines
      geom_hline(
        yintercept = median_value,
        linetype = "longdash", color = "gray85", linewidth = 0.7
      ) +
      geom_vline(
        xintercept = median_meeting_cost,
        linetype = "longdash", color = "gray85", linewidth = 0.7
      ) +

      # Add points with gray fill for all non-selected points
      geom_point(aes(size = decision_makers),
        shape = 21,
        fill = "gray70", # All bubbles gray
        color = "white",
        stroke = 1.5,
        alpha = 0.8
      ) +

      # Highlight selected points with green fill
      geom_point(
        data = filter(all_expos, is_selected),
        aes(size = decision_makers),
        fill = "#61A60E", # Green for selected
        color = "white",
        shape = 21,
        stroke = 1.5,
        alpha = 1
      ) +

      # Add labels for selected points
      geom_text_repel(
        data = filter(all_expos, is_selected),
        aes(label = roi_label),
        size = 5,
        color = "#61A60E",
        fontface = "bold",
        bg.color = "white",
        bg.r = 0.15,
        box.padding = 0.8,
        point.padding = 0.5,
        segment.size = 0.7,
        segment.color = "#61A60E",
        hjust = 0 # Left-align the text
      ) +
      scale_size_continuous(range = c(4, 12), guide = "none") +

      # Add quadrant labels
      annotate("text",
        x = min(all_expos$meeting_cost) + (median_meeting_cost - min(all_expos$meeting_cost)) / 2,
        y = max(all_expos$value_score) - (max(all_expos$value_score) - median_value) / 6,
        label = "HIGH VALUE\nLOW COST",
        fontface = "bold",
        color = "#b6d7a8",
        alpha = 0.6, # More transparent
        size = 5,
        vjust = 1,
        hjust = 0.5
      ) +
      annotate("text",
        x = median_meeting_cost + (max(all_expos$meeting_cost) - median_meeting_cost) / 2,
        y = max(all_expos$value_score) - (max(all_expos$value_score) - median_value) / 6,
        label = "HIGH VALUE\nHIGH COST",
        fontface = "bold",
        color = "#a2c4c9",
        alpha = 0.6, # More transparent
        size = 5,
        vjust = 1,
        hjust = 0.5
      ) +
      annotate("text",
        x = min(all_expos$meeting_cost) + (median_meeting_cost - min(all_expos$meeting_cost)) / 2,
        y = min(all_expos$value_score) + (median_value - min(all_expos$value_score)) / 6,
        label = "LOW VALUE\nLOW COST",
        fontface = "bold",
        color = "#f9cb9c",
        alpha = 0.6, # More transparent
        size = 5,
        hjust = 0.5
      ) +
      annotate("text",
        x = median_meeting_cost + (max(all_expos$meeting_cost) - median_meeting_cost) / 2,
        y = min(all_expos$value_score) + (median_value - min(all_expos$value_score)) / 6,
        label = "LOW VALUE\nHIGH COST",
        fontface = "bold",
        color = "#ea9999",
        alpha = 0.6, # More transparent
        size = 5,
        hjust = 0.5
      ) +
      scale_x_continuous(expand = c(0.1, 0), labels = scales::label_currency(prefix = "€")) +
      # Axis labels
      labs(
        x = "COST PER MEETING",
        y = "VALUE SCORE"
      ) +

      # Executive dashboard theme
      theme_minimal() +
      theme(
        text = element_text(family = "sans"),
        axis.title = element_blank(), # element_text(face = "bold", size = 14),
        axis.text = element_text(size = 12),
        legend.position = "none",
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "#FAFAFA", color = NA),
        plot.background = element_rect(fill = "#FAFAFA", color = NA),
        plot.margin = margin(t = 0, r = 0, b = 0, l = 0)
      )
    exec_quadrat
  })


  # 3. Event Effectiveness bar chart
  output$effectiveness_bar_plot <- renderPlot({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Get all expos for comparison
    all_expos <- expo_data()

    # Prepare data for Bar chart - normalize each metric to 0-100 scale
    # Select metrics to include in the chart
    bar_metrics <- c(
      "value_score", "relevance", "booth_visitors"
    )

    # CORRECTED: Function to normalize values to 0-100 scale with absolute scaling
    # This approach uses the known or theoretical min/max values for each metric
    # rather than scaling relative to the data
    normalize_absolute <- function(x, min_val = NULL, max_val = NULL) {
      # If min/max not provided, use the minimum 0 and either maximum value in data or a default max
      if (is.null(min_val)) min_val <- 0
      if (is.null(max_val)) max_val <- max(max(x, na.rm = TRUE), 1) # avoid division by zero

      # Return original value if max equals min
      if (max_val == min_val) {
        return(x)
      }

      # Scale the values between 0-100
      normalized <- 100 * (x - min_val) / (max_val - min_val)

      # Ensure values stay within 0-100 range (for values outside the expected range)
      normalized <- pmax(0, pmin(100, normalized))

      return(normalized)
    }

    # Create normalized data for bar chart with absolute scaling
    bar_data <- df_all

    # Define normalization parameters for each metric
    # Specify the expected min and max values for each metric
    normalization_params <- list(
      value_score = list(min = 0, max = 100), # Assuming value_score is on a 0-100 scale
      relevance = list(min = 0, max = 10) # Assuming relevance is on a 0-10 scale
    )

    # Apply normalization with specific parameters for each metric
    for (metric in bar_metrics) {
      # Skip booth_visitors as it's not directly normalized
      if (metric != "booth_visitors") {
        bar_data[[paste0(metric, "_normalized")]] <- normalize_absolute(
          bar_data[[metric]],
          min_val = normalization_params[[metric]]$min,
          max_val = normalization_params[[metric]]$max
        )
      }
    }

    # Calculate conversion rates and normalize them to 0-100 scale
    bar_data <- bar_data %>%
      # Calculate conversion rates as percentages (0-100%)

      # Calculate conversion_rate_meetings (% of booth visitors that become meetings)
      mutate(conversion_rate_meetings = ifelse(booth_visitors > 0,
        100 * meetings / booth_visitors,
        0
      )) %>%
      # Calculate conversion_rate_decision_makers (% of booth visitors that engage with decision makers)
      mutate(conversion_rate_decision_makers = ifelse(booth_visitors > 0,
        100 * decision_makers / booth_visitors,
        0
      )) %>%
      # Calculate conversion_new_connections (% of booth visitors that become new connections)
      mutate(conversion_new_connections = ifelse(booth_visitors > 0,
        100 * new_connections / booth_visitors,
        0
      )) %>%
      # Now normalize these conversion rates using the normalize_absolute function
      # with specific target ranges for each conversion metric
      mutate(
        # For meetings, typically 5-10% conversion is good, so scale accordingly
        conversion_rate_meetings_normalized = normalize_absolute(
          conversion_rate_meetings,
          min_val = 0,
          max_val = 25 # Assuming 25% conversion rate is excellent and would score 100
        ),

        # For decision makers, typically 2-5% conversion is good
        conversion_rate_decision_makers_normalized = normalize_absolute(
          conversion_rate_decision_makers,
          min_val = 0,
          max_val = 15 # Assuming 15% conversion rate is excellent and would score 100
        ),

        # For new connections, similar scaling
        conversion_new_connections_normalized = normalize_absolute(
          conversion_new_connections,
          min_val = 0,
          max_val = 20 # Assuming 20% conversion rate is excellent and would score 100
        )
      )

    # Final normalized metrics to use
    final_bar_metrics <- c(
      "value_score_normalized",
      "relevance_normalized",
      "conversion_rate_meetings_normalized",
      "conversion_rate_decision_makers_normalized",
      "conversion_new_connections_normalized"
    )

    # Filter for selected expo and year (assuming first row is selected)
    selected_bar_data <- bar_data %>%
      filter(expo_name == df_all$expo_name[1] & year == df_all$year[1]) %>%
      select(expo_name, year, all_of(final_bar_metrics))

    # Reshape for bar chart
    bar_long <- selected_bar_data %>%
      pivot_longer(
        cols = -c(expo_name, year),
        names_to = "metric",
        values_to = "value"
      ) %>%
      # Rename metrics for better labels
      mutate(metric = case_when(
        metric == "value_score_normalized" ~ "Overall Value",
        metric == "relevance_normalized" ~ "Industry Relevance",
        metric == "conversion_rate_meetings_normalized" ~ "Meeting Conversion",
        metric == "conversion_rate_decision_makers_normalized" ~ "Decision Maker Conversion",
        metric == "conversion_new_connections_normalized" ~ "New Connection Conversion",
        TRUE ~ metric
      ))

    # Create a dataframe for category averages (for comparison)
    # Calculate averages using the same absolute scaling
    category_averages <- bar_data %>%
      summarize(across(all_of(final_bar_metrics), mean, na.rm = TRUE)) %>%
      # Reshape
      pivot_longer(
        cols = everything(),
        names_to = "metric",
        values_to = "average"
      ) %>%
      # Rename metrics for better labels
      mutate(metric = case_when(
        metric == "value_score_normalized" ~ "Overall Value",
        metric == "relevance_normalized" ~ "Industry Relevance",
        metric == "conversion_rate_meetings_normalized" ~ "Meeting Conversion",
        metric == "conversion_rate_decision_makers_normalized" ~ "Decision Maker Conversion",
        metric == "conversion_new_connections_normalized" ~ "New Connection Conversion",
        TRUE ~ metric
      ))

    # Join the averages to the main data
    bar_long <- bar_long %>%
      left_join(category_averages, by = "metric")

    # Define a custom order for the metrics
    bar_long$metric <- factor(bar_long$metric,
      levels = c(
        "Overall Value", "Industry Relevance",
        "Meeting Conversion", "Decision Maker Conversion",
        "New Connection Conversion"
      )
    )

    # Create horizontal bar chart
    bar_plot <- ggplot(bar_long, aes(x = metric, y = value)) +
      # Add bars
      geom_bar(stat = "identity", fill = "#61A60E", width = 0.6, alpha = 0.8) +

      # Add average line
      geom_point(aes(y = average), color = "#B2B2B2", size = 3) +
      geom_segment(
        aes(
          x = as.numeric(metric) - 0.4, xend = as.numeric(metric) + 0.4,
          y = average, yend = average
        ),
        color = "#B2B2B2", linewidth = 1.2, linetype = "dashed"
      ) +

      # Add value labels
      geom_text(aes(label = round(value)), colour = "#61A60E", hjust = -0.3, size = 4, fontface = "bold") +

      # Add axis labels and title
      labs(
        x = "",
        y = "Performance (0-100 Scale)"
      ) +

      # Flip coordinates for horizontal bars
      coord_flip() +

      # Set y-axis limits
      scale_y_continuous(limits = c(0, 110), breaks = seq(0, 100, 25)) +

      # Apply clean theme
      theme_minimal() +
      theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.y = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.title.x = element_text(size = 12, face = "bold", margin = margin(t = 10)),
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 12, margin = margin(b = 15)),
        plot.caption = element_text(size = 9, color = "gray50", hjust = 0),
        plot.margin = margin(t = 0, r = 0, b = 0, l = 0)
      )
    bar_plot
  })



  # 5 Render performance over time chart
  output$performance_over_time <- renderPlot({
    req(expo_trend_data())
    trend_data <- expo_trend_data()

    if (nrow(trend_data) <= 1) {
      # Create empty plot with message if there's no trend data
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "Not enough data points\nto show performance over time") +
        theme_void() +
        xlim(0, 1) +
        ylim(0, 1)
    } else {
      # Create time series identifier
      trend_data <- trend_data %>%
        mutate(time_id = paste(year, times, sep = "-"))

      # Calculate conversion rates for each entry
      trend_data <- trend_data %>%
        mutate(
          dm_percentage = ifelse(booth_visitors > 0, round(decision_makers / booth_visitors * 100, 1), 0),
          meeting_conversion = ifelse(booth_visitors > 0, round(meetings / booth_visitors * 100, 1), 0),
          connection_conversion = ifelse(booth_visitors > 0, round(new_connections / booth_visitors * 100, 1), 0)
        )

      # Convert to long format for plotting
      trend_long <- trend_data %>%
        select(time_id, dm_percentage, meeting_conversion, connection_conversion) %>%
        pivot_longer(
          cols = c(dm_percentage, meeting_conversion, connection_conversion),
          names_to = "metric", values_to = "value"
        ) %>%
        mutate(metric = case_when(
          metric == "dm_percentage" ~ "Decision Makers %",
          metric == "meeting_conversion" ~ "Meeting Conversion %",
          metric == "connection_conversion" ~ "Connection Conversion %"
        ))

      # Create time series plot
      ggplot(trend_long, aes(x = time_id, y = value, group = metric, color = metric)) +
        geom_line(linewidth = 1) +
        geom_point(size = 3) +
        labs(title = "Performance Trends", x = "EXPO Instance", y = "Percentage (%)") +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_color_brewer(palette = "Set1") +
        ylim(0, max(trend_long$value) * 1.2)
    }
  })





  # 4. Industry Relevance vs. Performance Plot
  output$relevance_performance_plot <- renderPlot({
    req(selected_expo_data())
    data <- selected_expo_data()

    # Get all expos for comparison
    all_expos <- expo_data()

    # Add flag for selected expo and year
    all_expos <- all_expos %>%
      mutate(is_selected = (expo_name == data$expo_name[1] & year == data$year[1]))

    # Add year to expo name for labels
    all_expos <- all_expos %>%
      mutate(rel_label = paste0(expo_name, "- ", year, "\nScore:", value_score, "\nRelevancy:", relevance))



    # Calculate medians based on the new relevance variable
    median_relevance <- 5 # Relevance score is 1 - 10.
    median_value <- median(all_expos$value_score)

    # Recalculate quadrants using relevance instead of cost
    all_expos <- all_expos %>%
      mutate(quadrant = case_when(
        relevance <= median_relevance & value_score >= median_value ~ "Hidden Opportunity",
        relevance > median_relevance & value_score >= median_value ~ "Strategic Priority",
        relevance <= median_relevance & value_score < median_value ~ "Resource Drain",
        relevance > median_relevance & value_score < median_value ~ "Industry-Focused"
      ))


    # Create scatter plot
    relevance_score_plot <-
      ggplot(all_expos, aes(x = relevance, y = value_score)) +

      # Add reference lines
      geom_hline(
        yintercept = median_value,
        linetype = "longdash", color = "gray85", linewidth = 0.7
      ) +
      geom_vline(
        xintercept = median_relevance,
        linetype = "longdash", color = "gray85", linewidth = 0.7
      ) +

      # Add points with gray fill for all non-selected points
      geom_point(aes(size = decision_makers),
        shape = 21,
        fill = "gray70", # All bubbles gray
        color = "white",
        stroke = 1.5,
        alpha = 0.8
      ) +
      # Highlight selected points with green fill
      geom_point(
        data = filter(all_expos, is_selected),
        aes(size = decision_makers),
        fill = "#61A60E", # Green for selected
        color = "white",
        shape = 21,
        stroke = 1.5,
        alpha = 1
      ) +


      # Add trend line
      geom_smooth(method = "lm", se = FALSE, color = "darkgray", linetype = "dashed") +


      # Add labels for selected points
      geom_text_repel(
        data = filter(all_expos, is_selected),
        aes(label = ifelse(is_selected, rel_label, "")),
        size = 5,
        color = "#61A60E",
        fontface = "bold",
        bg.color = "white",
        bg.r = 0.15,
        box.padding = 0.8,
        point.padding = 0.5,
        segment.size = 0.7,
        segment.color = "#61A60E",
        hjust = 0 # Left-align the text
      ) +

      # Add quadrant labels
      annotate("text",
        x = min(all_expos$relevance) + (median_relevance - min(all_expos$relevance)) / 2,
        y = max(all_expos$value_score) - (max(all_expos$value_score) - median_value) / 6,
        label = "Hidden Opportunity",
        fontface = "bold",
        color = "#b6d7a8",
        alpha = 0.6, # More transparent
        size = 5,
        vjust = 1,
        hjust = 0.5
      ) +
      annotate("text",
        x = median_relevance + (max(all_expos$relevance) - median_relevance) / 2,
        y = max(all_expos$value_score) - (max(all_expos$value_score) - median_value) / 6,
        label = "Strategic Priority",
        fontface = "bold",
        color = "#a2c4c9",
        alpha = 0.6, # More transparent
        size = 5,
        vjust = 1,
        hjust = 0.5
      ) +
      annotate("text",
        x = min(all_expos$relevance) + (median_relevance - min(all_expos$relevance)) / 2,
        y = min(all_expos$value_score) + (median_value - min(all_expos$value_score)) / 6,
        label = "Resource Drain",
        fontface = "bold",
        color = "#ea9999",
        alpha = 0.6, # More transparent
        size = 5,
        hjust = 0.5
      ) +
      annotate("text",
        x = median_relevance + (max(all_expos$relevance) - median_relevance) / 2,
        y = min(all_expos$value_score) + (median_value - min(all_expos$value_score)) / 6,
        label = "Industry-Focused",
        fontface = "bold",
        color = "#f9cb9c",
        alpha = 0.6, # More transparent
        size = 5,
        hjust = 0.5
      ) +

      # Customize legend and scales
      scale_alpha_manual(values = setNames(c(1, 0.5), c(TRUE, FALSE)), guide = "none") +

      # Add theme and labels
      labs(
        x = "Industry Relevance Score", y = "Value Score",
        # title = "Industry Relevance vs. expo Value",
        # subtitle = "Bubble size indicates number of decision maker contacts"
      ) +
      theme_minimal() +
      theme(
        text = element_text(family = "Verdana"),
        axis.title = element_blank(), # element_text(face = "bold", size = 14),
        axis.text = element_text(size = 12),
        legend.position = "none",
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "#FAFAFA", color = NA),
        plot.background = element_rect(fill = "#FAFAFA", color = NA),
        plot.margin = margin(t = 0, r = 0, b = 0, l = 0)
      )

    relevance_score_plot
  })


  # Assign the file name
  filename <- reactive({
    # Get the currently selected expo data
    selected_data <- selected_expo_data()
    paste("Event-Report", "_", selected_data$location, "_", selected_data$year, ".pdf", sep = "") # selected_data
  })


  # reactive data frame of all expo data and for value_cost parameters
  all_expos <- reactive({
    # Get all expos
    all_expos_df <- expo_data()

    # Add labels for expos
    all_expos_df <- all_expos_df %>%
      mutate(expo_label = paste0(expo_name, "\n  (", year, ")"))

    # Calculate median values for quadrant divisions
    median_cost <- median(all_expos_df$cost)
    median_value <- median(all_expos_df$value_score)

    # Add quadrant info to points
    all_expos_df <- all_expos_df %>%
      mutate(
        quadrant = case_when(
          cost <= median_cost & value_score >= median_value ~ "Value Champion",
          cost > median_cost & value_score >= median_value ~ "Premium Investment",
          cost <= median_cost & value_score < median_value ~ "Low Priority",
          cost > median_cost & value_score < median_value ~ "Reconsider Commitment"
        )
      )

    # Don't reference 'data' here as it's not defined in this context
    return(all_expos_df)
  })

  # Export PDF
  output$generatePDF <- downloadHandler(
    filename = function() filename(),
    content = function(file) {
      withProgress(message = "Creating Report: ", value = 0, {
        incProgress(0.3, detail = "Collecting inputs...")

        # Get the currently selected expo data
        current_data <- selected_expo_data()

        # Write the selected dataframe to a temporary file
        temp_file <- tempfile(fileext = ".rds")
        saveRDS(current_data, temp_file) # data frame as selected_expo_data()

        # Calculate relevance category
        relevance_to_category <- function(relevance) {
          case_when(
            relevance >= 1 & relevance <= 3 ~ "SEED",
            relevance >= 4 & relevance <= 6 ~ "GROW",
            relevance >= 7 & relevance <= 9 ~ "ROOT",
            relevance == 10 ~ "FLORA",
            TRUE ~ NA_character_
          )
        }

        # Calculate actual relevance category
        rel_category <- relevance_to_category(current_data$relevance)

        # Get quadrant info for the selected expo
        all_expo_data <- all_expos()
        selected_expo_in_all <- all_expo_data %>%
          filter(expo_name == current_data$expo_name & year == current_data$year)

        # Write the selected dataframe to a temporary file
        temp_file2 <- tempfile(fileext = ".rds")
        saveRDS(all_expo_data, temp_file2) # data frame as  all_expos()


        # Create parameters
        params <- list(
          location = current_data$location,
          expo_name = current_data$expo_name,
          year = current_data$year,
          expo_name_year = paste(current_data$expo_name, " ", current_data$year, sep = ""),
          value_score = as.character(current_data$value_score),
          conversion_dm = paste(ifelse(current_data$booth_visitors > 0,
            round(current_data$decision_makers / current_data$booth_visitors * 100, 1),
            0
          ), "%"),
          conversion_meeting = paste(ifelse(current_data$booth_visitors > 0,
            round(current_data$meetings / current_data$booth_visitors * 100, 1),
            0
          ), "%"),
          conversion_nc = paste(ifelse(current_data$booth_visitors > 0,
            round(current_data$new_connections / current_data$booth_visitors * 100, 1),
            0
          ), "%"),
          conversion_nc_dm = paste(ifelse(current_data$booth_visitors > 0,
            round((current_data$new_connections + current_data$decision_makers) / current_data$booth_visitors * 100, 1),
            0
          ), "%"),
          cost_lead = paste(ifelse(current_data$booth_visitors > 0,
            round(current_data$cost / current_data$booth_visitors, 2),
            0
          ), "€"),
          cost_nc = paste(ifelse(current_data$new_connections > 0,
            round(current_data$cost / current_data$new_connections, 2),
            0
          ), "€"),
          cost_meeting = paste(ifelse(current_data$meetings > 0,
            round(current_data$cost / current_data$meetings, 1),
            0
          ), "€"),
          relevance_category = rel_category,
          value_cost = if (!is.null(selected_expo_in_all$quadrant)) selected_expo_in_all$quadrant else "Not categorized",
          effectiveness = ifelse(current_data$value_score > 70, "High",
            ifelse(current_data$value_score > 40, "Medium", "Low")
          ),
          relevance_performance = ifelse(current_data$relevance > 7, "High",
            ifelse(current_data$relevance > 4, "Medium", "Low")
          ),
          about_expo = current_data$about,
          purpose = current_data$purpose,
          conclusion = current_data$conclusion,
          notes = current_data$notes,
          competitors = current_data$competitors,
          df_all = temp_file2,
          df_selected = temp_file
        )

        incProgress(0.3, detail = "Building...")

        # Create temporary directory and copy files
        tempDir <- tempdir()
        tempReport <- file.path(tempDir, "report.qmd")

        # Copy the report template and assets (logos on header footer)
        file.copy("report.qmd", tempReport, overwrite = TRUE)
        dir.create(file.path(tempDir, "assets"), showWarnings = FALSE)
        file.copy("typst-show.typ", file.path(tempDir, "typst-show.typ"), overwrite = TRUE)
        file.copy("typst-template.typ", file.path(tempDir, "typst-template.typ"), overwrite = TRUE)

        # Set working directory to temp directory and render
        withr::with_dir(tempDir, {
          try({
            quarto::quarto_render(
              input = "report.qmd",
              output_format = "typst",
              execute_params = params
            )
          })

          incProgress(1, detail = "Downloading report...")

          # Copy the generated PDF
          generatedPDF <- sub("\\.qmd$", ".pdf", tempReport)
          file.copy(generatedPDF, file, overwrite = TRUE)
        })
      })
    }
  )
}
# Run the application
shinyApp(ui = ui, server = server)
